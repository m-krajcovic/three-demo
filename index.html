<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>My first three.js app</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script src="three.js"></script>
		<script>
			let scene = new THREE.Scene();
			const width = window.innerWidth;
			const height = window.innerHeight;

			const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 100000);
			

			var planeZ = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);

			let renderer = new THREE.WebGLRenderer();
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.body.appendChild(renderer.domElement);

			let geometry = new THREE.ConeGeometry( 1, 2, 3 );
			let material = new THREE.MeshBasicMaterial({color: 0x00ff00});
			let cube = new THREE.Mesh(geometry, material);

			scene.add(cube);

			camera.position.z = 50;
			// camera.updateProjectionMatrix();
			let movementSpeed = 0.5;
			let rotationSpeed = 0.1;

			// let degrees = 0;
			let radius = 1;
			let degrees = 0;

			let movementVector = {
				x: 1, y: 0, degrees: 0
			}

			let raycaster = new THREE.Raycaster();
			let mouse = new THREE.Vector2();

			let goal = getRandomPosition();
			renderer.domElement.addEventListener('mousemove', onDocumentMouseMove, false);
			window.addEventListener('resize', onWindowResize, false);



			function onDocumentMouseMove(event) {
				event.preventDefault();
				mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
				mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

				goal = {
					x: mouse.x,
					y: mouse.y
				};
				console.log(goal, mouse);
			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize(window.innerWidth, window.innerHeight);
			}

			function manageRaycasterIntersections(scene, camera) {
				camera.updateMatrixWorld();
				raycaster.setFromCamera(mouse, camera);
				var intersects = raycaster.intersectObjects(scene.children);
				
				// console.log(raycaster);

				if (intersects.length > 0) {
					
				} 
				else {

				}

				const pos = raycaster.ray.intersectPlane(planeZ);
				goal = pos;
			}

			function movePointByDegrees(degrees, radius) {
				const radians = 0.0174533 * degrees;
				return {
					x: radius * Math.cos(radians),
					y: radius * Math.sin(radians),
					degrees: degrees
				}
			}

			function getRandomPosition() {
				return {
					x: Math.floor(Math.random() * 30 - Math.random() * 30),
					y: Math.floor(Math.random() * 30 - Math.random() * 30)
				}
			}

			function getCubicDistance(x1, y1, x2, y2) {
				let a = x1 - x2;
				let b = y1 - y2;
				return a*a + b*b;
			}

			function getCubicDistanceFromGoal(point) {
				return getCubicDistance(goal.x, goal.y, cube.position.x + point.x, cube.position.y + point.y);
			}

			function indexOfMin(arr) {
				if (arr.length === 0) {
					return -1;
				}

				let min = arr[0];
				let minIndex = 0;
				for (let i = 1; i < arr.length; i++) {
					if (arr[i] < min) {
						minIndex = i;
						min = arr[i];
					}
				}
				return minIndex;
			}
			
			// goalCube.position.x = goal.x;
			// goalCube.position.y = goal.y;
			
			function getNewMovementVector() {
				const plusVector = movePointByDegrees(movementVector.degrees + 5, radius);
				const minusVector = movePointByDegrees(movementVector.degrees - 5, radius);
				const distances = [getCubicDistanceFromGoal(movementVector), getCubicDistanceFromGoal(plusVector), getCubicDistanceFromGoal(minusVector)];
				const minIndex = indexOfMin([getCubicDistanceFromGoal(movementVector), getCubicDistanceFromGoal(plusVector), getCubicDistanceFromGoal(minusVector)]);
				// console.log(distances);
				// console.log(distances[minIndex]);
				return [movementVector, plusVector, minusVector][minIndex];
			}
			let i = 0;
			function animate() {
				requestAnimationFrame(animate);

				// update movementVector to follow goal
				// check which angle is smallest from 3: straight vector, vector to left, vector to right
				// 
				manageRaycasterIntersections(scene, camera);
				if (!Math.sqrt(getCubicDistance(goal.x, goal.y, cube.position.x, cube.position.y) < 1)) {
					movementVector = getNewMovementVector();
				
					cube.position.x += movementVector.x * movementSpeed;
					cube.position.y += movementVector.y * movementSpeed;
					cube.rotation.z = movementVector.degrees * 0.0174533 - Math.PI/2;

					// const newPos = movePointByDegrees(i * 0.0174533, 10);
					// i++;
					// cube.position.x = newPos.x;
					// cube.position.y = newPos.y;
				

					// goal = getRandomPosition();
					// goalCube.position.x = goal.x;
					// goalCube.position.y = goal.y;
				}

				// cube.rotation.x += rotationSpeed;
				// goalCube.rotation.x += rotationSpeed;
				// cube.rotation.y += rotationSpeed;
				// goalCube.rotation.y += rotationSpeed;
				
				renderer.render(scene, camera);
			}
			animate();
		</script>
	</body>
</html>



